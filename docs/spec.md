# Спецификация механики аукциона — Telegram Gift Auctions

## Исходный продукт

Данная спецификация основана на анализе механики **Telegram Gift Auctions** — системы аукционов цифровых подарков (Collectible Gifts) в Telegram, введённой в 2024 году.

## Ключевые источники

- Официальная документация Telegram Fragment (анонс Gift Auctions)
- Наблюдения за реальными аукционами в Telegram (публичные данные)
- Telegram Bot API и Fragment платформа
- Обратная разработка на основе поведения UI и временных паттернов

## Термины

- **Аукцион (Auction)** — конкурс за получение ограниченного количества цифровых подарков
- **Лот (Lot)** — единица приза; один аукцион может иметь N лотов (N >= 1)
- **Раунд (Round)** — временной этап аукциона с фиксированной длительностью
- **Участник (Participant)** — пользователь, делающий ставки
- **Ставка (Bid)** — предложение участника о сумме, которую он готов заплатить
- **Eligibility (квалификация)** — право участника продолжать торги в следующем раунде
- **Hold (холд)** — резервирование средств на счёте участника
- **Capture (списание)** — конвертация hold в фактическое списание
- **Release (возврат)** — снятие hold без списания

---

## 1. Жизненный цикл аукциона

### 1.1. Состояния

```mermaid
stateDiagram-v2
    [*] --> draft
    draft --> active : start
    active --> finished : finalize
    active --> cancelled : cancel
    draft --> cancelled : cancel
    finished --> [*]
    cancelled --> [*]
```

#### draft (создан)
- Аукцион создан, но не стартовал
- Ставки запрещены
- Можно отменить без финансовых последствий

#### active (активен)
- Аукцион запущен, идёт раунд №1 или последующие
- Участники могут делать ставки (если eligible)
- Автоматические переходы раундов через Worker

#### finished (завершён)
- Определены победители (winners)
- Все финансовые операции закрыты
- Неизменяемое состояние

#### cancelled (отменён)
- Аукцион отменён администратором
- Все hold возвращены участникам
- Неизменяемое состояние

---

## 2. Модель лотов (TELEGRAM GIFT AUCTIONS)

### 2.1. Концепция - ФИКСИРОВАННОЕ количество призов

**КРИТИЧЕСКИ ВАЖНО:** В Telegram Gift Auctions аукцион имеет ФИКСИРОВАННОЕ общее количество призов:

- `lotsCount` — количество призов в каждом раунде
- `maxRounds` — максимальное количество раундов
- `totalLots = lotsCount × maxRounds` — общее количество призов (вычисляется)
- Аукцион заканчивается когда розданы ВСЕ `totalLots` призы
- Участники без приза просто проигрывают (scarcity model)

**Пример:**
- `lotsCount = 3` (призов в каждом раунде)
- `maxRounds = 4` (максимум 4 раунда)
- `totalLots = 3 × 4 = 12` (всего 12 призов)
- Раунд 1: 3 победителя
- Раунд 2: 3 победителя
- Раунд 3: 3 победителя
- Раунд 4: 3 победителя, аукцион завершен
- Всего роздано: 3+3+3+3 = 12 призов ✅

### 2.2. Распределение призов по раундам

**Механизм:**
1. В каждом раунде топ-`lotsCount` участников получают приз
2. Победители раунда ВЫБЫВАЮТ с призом (capture их hold)
3. Проигравшие продолжают в следующий раунд с накопленным hold
4. **Новые участники могут войти в любой раунд** (открытая система)
5. Подсчет: `lotsDistributed = roundWinners.length`
6. Условие окончания: `lotsDistributed >= totalLots`

**Открытая система раундов:**
- ✅ Новые участники МОГУТ входить в любой раунд (2, 3, 4...)
- ✅ Нет ограничения по `currentRoundEligible` для входа
- ✅ Это критично для соответствия Telegram механике
- ✅ Позволяет динамичное участие на протяжении всего аукциона

### 2.3. Финализация

**Условие:** `lotsDistributed >= totalLots` (ВСЕ призы розданы)

**Алгоритм:**
1. Все roundWinners уже получили capture при закрытии своих раундов
2. Оставшимся участникам (без призов) делается release
3. Массивы `winners` и `winningBids` заполняются из roundWinners
4. Статус → `finished`

**Финансы:**
- Победители раундов: `capture` уже выполнен при закрытии раунда
- Проигравшие: `release` при финализации
- Никаких дополнительных финансовых операций в finalize

**Важно:** Участники могут остаться без приза - это нормальное поведение scarcity model.

---

## 3. Раунды

### 3.1. Длительность

Каждый раунд имеет фиксированную базовую длительность `roundDurationSec`.

**Временные метки:**
- `scheduledEndsAt` — планируемое окончание без anti-sniping
- `endsAt` — фактическое окончание с учётом продлений (effective_end_at)

**Формула старта раунда:**
```
scheduledEndsAt = endsAt = now + roundDurationSec
```

### 3.2. Переход раунда

**Триггер:** Worker обнаруживает `currentRoundEndsAt <= now`

**Алгоритм:**
1. Получить топ-`lotsCount` участников по ставкам (победители раунда)
2. Capture hold для победителей раунда
3. Проверить условие завершения: `lotsDistributed >= totalLots`
4. Если завершение → финализация (release hold оставшимся)
5. Иначе → переход на раунд N+1:
   - `currentRoundNo += 1`
   - `currentRoundEndsAt = now + roundDurationSec`
   - Все участники без приза продолжают (carry-over)

### 3.3. Открытая система участия

**ВАЖНО:** Открытая система — новые участники могут войти в любой раунд.

**Правила:**
- Новые участники могут делать ставки в раундах 2, 3, 4 и т.д.
- Нет ограничения по `currentRoundEligible` для новых участников
- Используется максимальная ставка участника по всем раундам

**Ранжирование:**
1. Максимальная ставка участника за ВСЕ раунды (desc)
2. Время первой ставки с этой суммой (asc) — tie-breaker

**Carry-over ставок:**
- Участник НЕ обязан делать новую ставку в каждом раунде
- Ставки автоматически переносятся между раундами
- Используется максимальная ставка для ранжирования

---

## 4. Ставки

### 4.1. Минимальный шаг (Min Increment)

**Правило:** Каждая новая ставка участника должна превышать его текущую на минимальный шаг.

```
newAmount >= currentAmount + minIncrement
```

**Где:**
- `currentAmount` — максимальная ставка участника в аукционе (по всем раундам)
- `minIncrement` — параметр аукциона (фиксированная сумма)

**Ошибка:** `422 UnprocessableEntity` если правило нарушено.

### 4.2. Текущая ставка участника

**Модель:** Одна активная ставка на участника в аукционе.

В БД хранятся все ставки как события (`Bid` documents), но «активная ставка» вычисляется как:
```
max(amount) WHERE participantId = X AND status = 'placed'
```

При повышении ставки:
- Создаётся новый документ `Bid` с большей суммой
- Старая ставка остаётся (история), но эффективная ставка = max

### 4.3. Ранжирование

**Сортировка участников:**
1. Максимальная ставка (desc)
2. Время фиксации этой ставки (asc)

**Tie-breaking:** Если две ставки равны, побеждает участник, сделавший ставку раньше.

**Реализация:**
```javascript
// Агрегация: получить max amount per participant + earliest createdAt
BidModel.aggregate([
  { $match: { auctionId, status: 'placed' } },
  { $sort: { amount: -1, createdAt: 1 } },
  { $group: {
      _id: '$participantId',
      amount: { $first: '$amount' },
      committedAt: { $first: '$createdAt' }
  }},
  { $sort: { amount: -1, committedAt: 1 } }
])
```

### 4.4. Валидация времени

**Правило:** Ставка отклоняется, если `now >= currentRoundEndsAt`.

**Код:** `409 Conflict: "round is already closed"`

**Гонка:** Возможна ситуация, когда ставка проходит проверку времени, но Worker уже начал закрытие раунда. Защита через условный update в транзакции.

---

## 5. Anti-Sniping

### 5.1. Проблема

**Sniping** — стратегия размещения ставки в последнюю секунду, чтобы конкуренты не успели ответить.

**Решение:** Автоматическое продление раунда при активности в последние N секунд.

### 5.2. Параметры

- `snipingWindowSec` — окно (последние N секунд раунда), в котором триггерится продление
- `extendBySec` — на сколько секунд продлевать
- `maxExtensionsPerRound` — лимит продлений (защита от бесконечного раунда)

**Пример:**
```
snipingWindowSec = 10
extendBySec = 10
maxExtensionsPerRound = 5
```

### 5.3. Правило продления

**Условие (все должны выполняться):**
1. `extendBySec > 0`
2. `snipingWindowSec > 0`
3. `maxExtensionsPerRound > 0`
4. Ставка сделана в окне: `now >= endsAt - snipingWindowSec`
5. Лимит не исчерпан: `extensionsCount < maxExtensionsPerRound`
6. **Ставка конкурентная:** `newBid > currentLeaderBid` (обгоняет текущего лидера)

**КРИТИЧЕСКИ ВАЖНО:** Продление раунда происходит ТОЛЬКО при конкурентных ставках, которые обгоняют текущего лидера. Это защищает от бесконечного продления раунда спамом микроставок.

**Конкурентная ставка:**
- Новая ставка должна превышать ставку текущего лидера раунда
- Микроставки без обгона лидера НЕ продлевают раунд
- Защита от спама и манипуляций таймером раунда
- Обеспечивает честную конкуренцию

**Алгоритм проверки конкурентности:**
```javascript
// Получаем текущего лидера (максимальную ставку в раунде)
const currentLeader = await BidModel.findOne({
  auctionId,
  status: 'placed',
  participantId: { $nin: excludeRoundWinners }
})
  .sort({ amount: -1, createdAt: 1 })
  .lean();

const currentLeaderAmount = currentLeader?.amount || '0';
const isCompetitiveBid = compare(newAmount, currentLeaderAmount) > 0;

// Продление только если конкурентная
if (isCompetitiveBid && /* остальные условия */) {
  extendRound();
}
```

**Формула нового endsAt:**
```
candidateEndsAt = max(currentEndsAt, now) + extendBySec
```

**Обоснование:** Гарантирует минимум `extendBySec` секунд от момента ставки, даже если сервер обрабатывает запрос с задержкой.

### 5.4. Атомарность

Продление происходит **в той же транзакции**, что и запись ставки.

**Условный update:**
```javascript
AuctionModel.updateOne(
  {
    _id: auctionId,
    status: 'active',
    currentRoundNo: roundNo,
    currentRoundEndsAt: { $lt: candidateEndsAt },
    rounds: { $elemMatch: {
      roundNo,
      status: 'active',
      extensionsCount: { $lt: maxExtensions }
    }},
    $expr: {
      $and: [
        { $lt: [now, '$currentRoundEndsAt'] },
        { $gte: [now, { $subtract: ['$currentRoundEndsAt', windowMs] }] }
      ]
    }
  },
  {
    $set: {
      currentRoundEndsAt: candidateEndsAt,
      'rounds.$[r].endsAt': candidateEndsAt
    },
    $inc: { 'rounds.$[r].extensionsCount': 1 }
  }
)
```

**Если update прошёл:** `effectiveEndsAt = candidateEndsAt`  
**Если не прошёл:** Ставка принята, но продления не было (лимит исчерпан или конкурентная ставка)

### 5.5. Отличия от классического варианта

**Классическая формула (аукционы eBay):**
```
endsAt = max(endsAt, now + extendBySec)
```

**Наша реализация:**
```
endsAt = max(endsAt, now) + extendBySec
```

**Разница:** Мы всегда гарантируем полные `extendBySec` секунд от момента ставки, что честнее при высоких нагрузках.

---

## 6. Финансовые потоки

### 6.1. Hold на ставке (с carry-over)

**Правило:** При размещении/повышении ставки холд увеличивается только на **дельту**.

```
delta = newAmount - currentAmount
hold += delta
```

**Обоснование:** Избежать двойного резервирования. Если участник повышает ставку с 100 до 150, холд увеличивается на 50, а не на 150.

**Carry-over между раундами:**
- Hold накапливается на протяжении всех раундов
- Участник НЕ обязан делать новую ставку в каждом раунде
- Используется максимальная ставка по всем раундам

**TxId для идемпотентности:**
```
holdTxId = `hold:${auctionId}:${roundNo}:${participantId}:${idempotencyKey ?? newAmount}`
```

### 6.2. Capture для победителей раунда

**Когда:** При закрытии раунда для топ-`lotsCount` участников.

**Алгоритм:**
1. Определить топ-`lotsCount` участников текущего раунда
2. Для каждого победителя: `captureHold(participantId, maxAmount)`
3. Добавить в список `roundWinners`

**Эффект:**
- `hold -= amount`
- `balance -= amount`
- Средства списаны с баланса
- Участник получает приз и ВЫБЫВАЕТ

**TxId:**
```
captureTxId = `close:${auctionId}:${roundNo}:${participantId}:capture`
```

### 6.3. Release при финализации

**Когда:** При финализации аукциона для оставшихся участников без приза.

**Алгоритм:**
1. Все участники с активными ставками, не получившие приз
2. Для каждого: `releaseHold(participantId, maxAmount)`

**Эффект:**
- `hold -= amount`
- `balance` без изменений
- Средства возвращаются в доступный баланс

**TxId:**
```
releaseTxId = `finalize:${auctionId}:${participantId}:release`
```

### 6.4. Преимущества текущей модели

**Текущая модель:**
- ✅ Hold накапливается на протяжении всех раундов (carry-over)
- ✅ Capture при победе в раунде (немедленное списание)
- ✅ Release при финализации для проигравших
- ✅ Простота для участников — не нужно повторять ставку
- ✅ Соответствует логике Telegram Gift Auctions

### 6.5. Отмена аукциона (Cancel)

**Сценарий:** Администратор отменяет аукцион до завершения.

**Алгоритм:**
1. Получить всех участников с placed bids
2. Для каждого: `releaseHold(participantId, maxAmount)`
3. `status = 'cancelled'`

**TxId:**
```
cancelTxId = `cancel:${auctionId}:${participantId}:release`
```

**Идемпотентность:** Повторный cancel не делает дубликатов release (проверка `txId` в ledger).

---

## 7. Конкурентность и восстановление

### 7.1. Транзакции MongoDB

**Требование:** Replica set (минимум single-node replica set для локальной разработки).

**Стратегия:** `withTransactionRetries` — автоповтор транзакций при временных ошибках (WriteConflict).

**Критические операции в транзакции:**
1. Размещение ставки: hold + запись bid + продление endsAt
2. Закрытие раунда: release для вылетевших + условный update auction
3. Финализация: capture для winners + release для проигравших + update auction

### 7.2. Идемпотентность ставок

**Механизм:** Уникальный индекс на `(auctionId, roundNo, participantId, idempotencyKey)`.

**Поведение:**
- Первая ставка с ключом → успех
- Повторная ставка с тем же ключом → `11000 DuplicateKey` → подавляется как идемпотентный повтор

**Ledger:** Hold также идемпотентен через уникальный `txId`.

### 7.3. Идемпотентность закрытия раунда

**Проблема:** Несколько Worker инстансов или ручное закрытие + Worker.

**Решение:** Условный update с проверкой `currentRoundNo` и `rounds[].status`.

```javascript
AuctionModel.updateOne(
  {
    _id: auctionId,
    status: 'active',
    currentRoundNo: roundNo,
    rounds: { $elemMatch: { roundNo, status: 'active' } }
  },
  { $set: { ... } }
)
```

**Если `modifiedCount !== 1`:** Транзакция прерывается → rollback ledger операций.

### 7.4. Восстановление после рестарта

**Текущая стратегия:** Active recovery через Worker + Reconcile Worker.

**Алгоритм:**
1. Worker периодически ищет `status=active AND currentRoundEndsAt <= now`
2. Закрывает просроченные раунды
3. Индекс `{ status: 1, currentRoundEndsAt: 1 }` обеспечивает быстрый поиск

**Reconcile Worker (✅ реализован):**
- Проверяет инвариант `total = available + held` для всех аккаунтов
- Обнаруживает зависшие holds после завершения аукционов (orphaned holds)
- Проверяет соответствие holds активным ставкам
- Автоматически исправляет безопасные случаи (release orphaned holds)
- Создаёт записи для ручного разбора сложных случаев

**Compensating Transactions:**
- При ошибках capture/release в финализации создаются записи `ReconcileIssue`
- Reconcile worker пытается исправить их при следующем запуске
- После 3 неудачных попыток issue переходит в статус `manual_review`
- Модель `ReconcileIssue` отслеживает тип проблемы, детали, попытки исправления

**Что НЕ делается:**
- Пересчёт effective_end_at по событиям (доверяем denormalized полям)

---

## 8. Наблюдаемость

### 8.1. Метрики

- `bids_total{status, reason}` — счётчик ставок (ok/rejected с причинами)
- Prometheus endpoint: `GET /metrics`

### 8.2. Логирование

**Формат:** JSON (structured logs)

**Критические события:**
- `[auction] finalize: currentRoundEligible is empty` — диагностика пустого раунда
- Worker errors (подавляются в catch, но требуют attention)

### 8.3. Диагностика конфликтов

**Ошибка:** `close race` в catch block

**Значение:** Конкурентное закрытие раунда. Транзакция откатилась (это норма).

**Действие:** Повторный Worker tick обработает аукцион повторно, если раунд всё ещё просрочен.

---

## 9. Архитектурные решения

### 9.1. Embedded rounds vs отдельная коллекция

**Решение:** Embedded `rounds` массив в `Auction` документе.

**Обоснование:**
- Атомарные обновления раунда и аукциона
- Нет необходимости в join'ах
- История раундов компактна (обычно < 10 раундов)

**Trade-off:** Ограничение на 16MB документа Mongo (не проблема для аукционов).

### 9.2. Denormalization: currentRoundNo/currentRoundEndsAt

**Решение:** Дублирование на корне документа.

**Обоснование:**
- Быстрые запросы Worker'а: `{ status: 'active', currentRoundEndsAt: { $lte: now } }`
- Избежать $elemMatch в критических запросах

**Консистентность:** Обновляется атомарно в той же операции, что и embedded round.

### 9.3. Ledger: single-entry vs double-entry

**Решение:** Simplified single-entry (debit=credit account).

**Обоснование:**
- Для демо-проекта достаточно одного account на участника
- Нет внешних платёжных систем
- Упрощённая reconcile логика

**Trade-off:** Сложнее масштабировать на multi-currency или escrow сценарии.

### 9.4. Worker polling vs event-driven

**Решение:** Worker с интервалом `WORKER_INTERVAL_MS` (default 1000ms).

**Обоснование:**
- Простота реализации
- Индекс обеспечивает эффективность выборки
- Для конкурса достаточно

**Trade-off:** Задержка до 1 секунды на закрытие раунда (приемлемо для roundDurationSec >= 30).

**Альтернатива:** TTL index Mongo + Change Streams (сложнее, но реалтаймнее).

---

## 10. Ограничения и компромиссы

### 10.1. Точность денежных расчётов

**Решение:** Decimal128 в Mongo + строковые операции через `money` helpers.

**Компромисс:** В конфигурации anti-sniping используется `Number()` (но это не деньги, а секунды).

**Критично:** Избегать `Number()` для сумм ставок/балансов.

### 10.2. Отсутствие Outbox pattern

**Статус:** Модель `OutboxEvent` присутствует, но не используется.

**Последствия:**
- Нет гарантированной доставки событий во внешние системы
- Невозможность воспроизвести историю по событиям

**Рекомендация:** Для продакшена добавить Outbox publisher.

### 10.3. Отсутствие модели Lot

**Статус:** Лоты представлены числом `lotsCount`, но нет отдельной коллекции `Lot` с индивидуальными свойствами.

**Последствия:**
- Невозможно разыгрывать разные призы в одном аукционе
- Winners и winningBids — просто массивы

**Обоснование:** Telegram Gift Auctions разыгрывают идентичные подарки.

### 10.4. Транзакции на standalone MongoDB

**Проблема:** Standalone Mongo (без replica set) не поддерживает транзакции.

**Решение:** Docker compose настроен на single-node replica set `rs0`.

**Продакшен:** Требуется полноценный replica set (минимум 3 ноды).

---

## 11. Соответствие Telegram Gift Auctions

### 11.1. Наблюдаемое поведение

На основе анализа публичных аукционов в Telegram Fragment:

1. **Многораундовая система:** ✅ Реализована
2. **Открытая система раундов:** ✅ Новые участники могут входить в любой раунд
3. **Carry-over ставок:** ✅ Ставки автоматически переносятся между раундами
4. **Anti-sniping с конкурентными ставками:** ✅ Реализован с проверкой обгона лидера
5. **Hold → Capture для победителей:** ✅ Реализовано при закрытии раунда
6. **Tie-breaking по времени:** ✅ Реализовано (earliest wins)
7. **Модель лотов:** ✅ `totalLots = lotsCount × maxRounds`

### 11.2. Различия и адаптации

| Аспект | Telegram | Наша реализация | Обоснование |
|--------|----------|-----------------|-------------|
| Валюта | TON (Toncoin) | Любая (RUB default) | Демо-проект |
| Платёжная система | Telegram Wallet | Виртуальные балансы | Упрощение |
| UI | Telegram Mini App | Web UI (standalone) | Независимость |
| Продление формула | Неизвестна точно | `max(endsAt, now) + extend` | Консервативный подход |
| Reconcile | Предполагается | Отсутствует | MVP scope |

### 11.3. Доверенные допущения

- **Финализация:** Capture происходит только при завершении аукциона (не по раундам)
- **Release:** Вылетевшие получают release немедленно (не ждут финализации)
- **MaxExtensions:** Лимит продлений необходим (иначе раунд может длиться бесконечно)

---

## 12. Тестирование механики

### 12.1. Unit tests

Покрыто в `test/auctions.test.ts`:
- Создание и старт аукциона
- Размещение ставок и min increment
- Eligibility (отсев участников)
- Финализация при `qualified <= lotsCount`
- Отмена аукциона и release holds

### 12.2. Load tests (k6)

`load/k6.js`:
- Конкурентные ставки от 100 участников
- Проверка инвариантов балансов (`available >= 0`)
- Anti-sniping режим с высокой интенсивностью в окне

### 12.3. Ручное тестирование

UI сценарий:
1. Создать аукцион с `lotsCount=2`, `topK=3`, `roundDurationSec=30`
2. Запустить 5 участников (ботов)
3. Наблюдать отсев после раунда 1 (остаётся 3)
4. После раунда 2 финализация (остаётся 2)
5. Проверить `winners` и release для проигравших

---

## 13. Рекомендации для продакшена

### 13.1. Уже реализовано

1. ✅ **Reconcile job:** Периодическая проверка consistency между hold и active bids
   - Проверка инвариантов балансов
   - Обнаружение orphaned holds
   - Автоматическое исправление с compensating transactions
   - Модель ReconcileIssue для отслеживания проблем

2. ✅ **Optimistic locking:** Retry механизм для конкурентных операций
   - `withTransactionRetries` для MongoDB транзакций
   - Условные обновления с проверкой статуса

3. ✅ **Metrics:** Prometheus метрики для мониторинга
   - `bids_total{status, reason}` — ставки по статусам
   - Встроенный endpoint `/metrics`

4. ✅ **55 тестов:** Покрытие критических сценариев
   - Финансовые операции
   - Конкурентность
   - Eligibility и отсев
   - Anti-sniping

### 13.2. Требуется для production

1. **Replica set:** Минимум 3 ноды MongoDB (обязательно)
2. **Мониторинг:** Alerting на долгие раунды, большие дельты времени
3. **Outbox events:** Публикация доменных событий для интеграций (если требуется)

### 13.3. Опциональные расширения

1. **Lot модель:** Индивидуальные призы (редкость, метаданные)
2. **Cancel policy:** Возможность частичной отмены (только новые ставки)
3. **Bid history API:** Публичная лента ставок для transparency
4. **WebSocket:** Реалтайм обновления лидерборда

---

## Заключение

Данная спецификация описывает production-ready реализацию многораундовой аукционной системы, основанной на механике Telegram Gift Auctions. Ключевые особенности:

- **Открытая система раундов** — новые участники могут входить в любой раунд
- **Carry-over ставок** — ставки автоматически переносятся между раундами
- **Anti-sniping для конкурентных ставок** — продление только при обгоне лидера
- **Модель распределения лотов** — `totalLots = lotsCount × maxRounds`
- **Hold-based финансы** — capture при победе в раунде
- **Tie-breaking** по времени для честности

Реализация обеспечивает атомарность через MongoDB транзакции, идемпотентность через уникальные ключи, и наблюдаемость через метрики/логи.
